# -*- coding: utf-8 -*-
"""socket.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WgrYDNus79mPCnIwyr69ifiO2YPII3SD
"""

!pip install scapy==2.4.5          # Advanced packet manipulation
! pip install matplotlib==3.5.3     # Traffic visualization
!pip install pandas==1.5.3         # Data analysis
!pip install numpy==1.24.3         # Numerical operations
!pip install psutil==5.9.4

pip install scapy==2.4.5          # Advanced packet manipulation
matplotlib==3.5.3     # Traffic visualization
pandas==1.5.3         # Data analysis
numpy==1.24.3         # Numerical operations
psutil==5.9.4

pip install scapy==2.4.5          # Advanced packet manipulation
matplotlib==3.5.3     # Traffic visualization
pandas==1.5.3         # Data analysis
numpy==1.24.3         # Numerical operations
psutil==5.9.4

#!/usr/bin/env python3
"""
Network Intrusion Detection System (NIDS)
Educational implementation for legitimate security monitoring
"""

import socket
import struct
import threading
import time
import json
import logging
from datetime import datetime
from collections import defaultdict, deque
import ipaddress

class NetworkIDS:
    def __init__(self):
        self.alerts = []
        self.traffic_stats = defaultdict(int)
        self.connection_tracker = defaultdict(list)
        self.suspicious_ips = set()
        self.port_scan_detector = defaultdict(lambda: deque(maxlen=50))
        self.running = False

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('nids.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

        # Define suspicious ports (commonly targeted)
        self.suspicious_ports = {
            21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443,
            993, 995, 1433, 1521, 3306, 3389, 5432, 5900
        }

        # Rate limiting thresholds
        self.connection_threshold = 50  # connections per IP per minute
        self.port_scan_threshold = 10   # different ports per IP per minute

    def create_raw_socket(self):
        """Create raw socket for packet capture"""
        try:
            # Create raw socket (requires root/admin privileges)
            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            return s
        except PermissionError:
            self.logger.error("Raw socket requires root/administrator privileges")
            return None
        except Exception as e:
            self.logger.error(f"Error creating raw socket: {e}")
            return None

    def parse_ip_header(self, data):
        """Parse IP header from raw packet data"""
        try:
            # Unpack the first 20 bytes (IP header)
            ip_header = struct.unpack('!BBHHHBBH4s4s', data[:20])

            version_ihl = ip_header[0]
            version = version_ihl >> 4
            ihl = (version_ihl & 0xF) * 4

            protocol = ip_header[6]
            src_ip = socket.inet_ntoa(ip_header[8])
            dst_ip = socket.inet_ntoa(ip_header[9])

            return {
                'version': version,
                'ihl': ihl,
                'protocol': protocol,
                'src_ip': src_ip,
                'dst_ip': dst_ip,
                'header_length': ihl
            }
        except Exception as e:
            self.logger.debug(f"Error parsing IP header: {e}")
            return None

    def parse_tcp_header(self, data, ip_header_length):
        """Parse TCP header from packet data"""
        try:
            tcp_header_start = ip_header_length
            tcp_header = struct.unpack('!HHLLBBHHH', data[tcp_header_start:tcp_header_start+20])

            src_port = tcp_header[0]
            dst_port = tcp_header[1]
            flags = tcp_header[5]

            return {
                'src_port': src_port,
                'dst_port': dst_port,
                'flags': flags,
                'syn': bool(flags & 0x02),
                'ack': bool(flags & 0x10),
                'fin': bool(flags & 0x01),
                'rst': bool(flags & 0x04)
            }
        except Exception as e:
            self.logger.debug(f"Error parsing TCP header: {e}")
            return None

    def detect_port_scan(self, src_ip, dst_port):
        """Detect potential port scanning activity"""
        current_time = time.time()

        # Add current port to the tracking deque
        self.port_scan_detector[src_ip].append((dst_port, current_time))

        # Count unique ports accessed in the last minute
        recent_ports = set()
        for port, timestamp in self.port_scan_detector[src_ip]:
            if current_time - timestamp <= 60:  # Last minute
                recent_ports.add(port)

        if len(recent_ports) >= self.port_scan_threshold:
            return True
        return False

    def detect_suspicious_activity(self, packet_info):
        """Analyze packet for suspicious patterns"""
        alerts = []
        src_ip = packet_info['ip']['src_ip']
        dst_port = packet_info.get('tcp', {}).get('dst_port', 0)

        # Check for port scanning
        if self.detect_port_scan(src_ip, dst_port):
            alerts.append({
                'type': 'PORT_SCAN',
                'severity': 'HIGH',
                'src_ip': src_ip,
                'description': f'Potential port scan detected from {src_ip}',
                'timestamp': datetime.now().isoformat()
            })
            self.suspicious_ips.add(src_ip)

        # Check for connections to suspicious ports
        if dst_port in self.suspicious_ports:
            alerts.append({
                'type': 'SUSPICIOUS_PORT',
                'severity': 'MEDIUM',
                'src_ip': src_ip,
                'dst_port': dst_port,
                'description': f'Connection to commonly targeted port {dst_port}',
                'timestamp': datetime.now().isoformat()
            })

        # Check for high connection rate
        current_time = time.time()
        self.connection_tracker[src_ip].append(current_time)

        # Clean old connections (older than 1 minute)
        self.connection_tracker[src_ip] = [
            t for t in self.connection_tracker[src_ip]
            if current_time - t <= 60
        ]

        if len(self.connection_tracker[src_ip]) > self.connection_threshold:
            alerts.append({
                'type': 'HIGH_CONNECTION_RATE',
                'severity': 'HIGH',
                'src_ip': src_ip,
                'description': f'High connection rate from {src_ip}: {len(self.connection_tracker[src_ip])} connections/minute',
                'timestamp': datetime.now().isoformat()
            })
            self.suspicious_ips.add(src_ip)

        return alerts

    def process_packet(self, data):
        """Process individual network packet"""
        ip_info = self.parse_ip_header(data)
        if not ip_info or ip_info['protocol'] != 6:  # Only process TCP packets
            return

        tcp_info = self.parse_tcp_header(data, ip_info['header_length'])
        if not tcp_info:
            return

        packet_info = {
            'ip': ip_info,
            'tcp': tcp_info,
            'timestamp': datetime.now().isoformat()
        }

        # Update traffic statistics
        self.traffic_stats[ip_info['src_ip']] += 1
        self.traffic_stats['total_packets'] += 1

        # Detect suspicious activity
        alerts = self.detect_suspicious_activity(packet_info)

        # Log alerts
        for alert in alerts:
            self.alerts.append(alert)
            self.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

    def start_monitoring(self, duration=60):
        """Start network monitoring for specified duration"""
        sock = self.create_raw_socket()
        if not sock:
            self.logger.error("Cannot start monitoring without raw socket")
            return

        self.running = True
        self.logger.info("Starting network intrusion detection...")

        start_time = time.time()
        try:
            while self.running and (time.time() - start_time < duration):
                try:
                    data, addr = sock.recvfrom(65535)
                    self.process_packet(data)
                except socket.timeout:
                    continue
                except Exception as e:
                    self.logger.debug(f"Packet processing error: {e}")

        except KeyboardInterrupt:
            self.logger.info("Monitoring stopped by user")
        finally:
            sock.close()
            self.running = False

    def generate_report(self):
        """Generate security report"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'monitoring_duration': '60 seconds',
            'total_packets': self.traffic_stats['total_packets'],
            'total_alerts': len(self.alerts),
            'suspicious_ips': list(self.suspicious_ips),
            'top_talkers': dict(sorted(
                {k: v for k, v in self.traffic_stats.items() if k != 'total_packets'}.items(),
                key=lambda x: x[1], reverse=True
            )[:10]),
            'alerts_by_type': {},
            'recent_alerts': self.alerts[-10:]  # Last 10 alerts
        }

        # Count alerts by type
        for alert in self.alerts:
            alert_type = alert['type']
            if alert_type not in report['alerts_by_type']:
                report['alerts_by_type'][alert_type] = 0
            report['alerts_by_type'][alert_type] += 1

        return report

    def save_report(self, filename='nids_report.json'):
        """Save report to JSON file"""
        report = self.generate_report()
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        self.logger.info(f"Report saved to {filename}")
        return report

# Simulated packet generator for testing (when raw sockets aren't available)
class PacketSimulator:
    def __init__(self, ids_system):
        self.ids = ids_system

    def simulate_normal_traffic(self):
        """Simulate normal network traffic"""
        import random

        normal_ips = ['192.168.1.10', '192.168.1.11', '192.168.1.12']
        normal_ports = [80, 443, 8080]

        for _ in range(50):
            src_ip = random.choice(normal_ips)
            dst_port = random.choice(normal_ports)

            # Simulate packet info
            packet_info = {
                'ip': {'src_ip': src_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': dst_port, 'src_port': random.randint(1024, 65535)}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.1)

    def simulate_port_scan(self):
        """Simulate port scanning attack"""
        attacker_ip = '10.0.0.100'

        self.ids.logger.info("Simulating port scan attack...")
        for port in range(20, 35):  # Scan ports 20-34
            packet_info = {
                'ip': {'src_ip': attacker_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': port, 'src_port': 12345}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.2)

# Main execution
if __name__ == "__main__":
    # Create IDS instance
    nids = NetworkIDS()

    print("Network Intrusion Detection System")
    print("=" * 40)

    # Check if we can use raw sockets
    test_socket = nids.create_raw_socket()
    if test_socket:
        test_socket.close()
        print("Raw socket available - starting real network monitoring...")
        nids.start_monitoring(duration=30)  # Monitor for 30 seconds
    else:
        print("Raw socket not available - running simulation mode...")
        simulator = PacketSimulator(nids)

        # Run simulations in separate threads
        import threading

        normal_thread = threading.Thread(target=simulator.simulate_normal_traffic)
        scan_thread = threading.Thread(target=simulator.simulate_port_scan)

        normal_thread.start()
        time.sleep(2)
        scan_thread.start()

        normal_thread.join()
        scan_thread.join()

    # Generate and display report
    print("\nGenerating security report...")
    report = nids.save_report()

    print(f"\nSecurity Report Summary:")
    print(f"Total Packets: {report['total_packets']}")
    print(f"Total Alerts: {report['total_alerts']}")
    print(f"Suspicious IPs: {len(report['suspicious_ips'])}")

    if report['alerts_by_type']:
        print("\nAlerts by Type:")
        for alert_type, count in report['alerts_by_type'].items():
            print(f"  {alert_type}: {count}")

    if report['recent_alerts']:
        print("\nRecent Alerts:")
        for alert in report['recent_alerts'][-3:]:  # Show last 3
            print(f"  {alert['type']}: {alert['description']}")

#!/usr/bin/env python3
"""
Network Intrusion Detection System (NIDS)
Educational implementation for legitimate security monitoring
"""

import socket
import struct
import threading
import time
import json
import logging
from datetime import datetime
from collections import defaultdict, deque
import ipaddress

class NetworkIDS:
    def __init__(self):
        self.alerts = []
        self.traffic_stats = defaultdict(int)
        self.connection_tracker = defaultdict(list)
        self.suspicious_ips = set()
        self.port_scan_detector = defaultdict(lambda: deque(maxlen=50))
        self.alert_cooldown = defaultdict(float)  # Track last alert time per IP
        self.running = False

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('nids.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

        # Define suspicious ports (commonly targeted)
        self.suspicious_ports = {
            21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443,
            993, 995, 1433, 1521, 3306, 3389, 5432, 5900
        }

        # Rate limiting thresholds
        self.connection_threshold = 50  # connections per IP per minute
        self.port_scan_threshold = 10   # different ports per IP per minute
        self.alert_cooldown_period = 60  # seconds between duplicate alerts

    def should_alert(self, alert_key, current_time):
        """Check if enough time has passed since last alert of this type for this IP"""
        if alert_key not in self.alert_cooldown:
            self.alert_cooldown[alert_key] = current_time
            return True

        if current_time - self.alert_cooldown[alert_key] >= self.alert_cooldown_period:
            self.alert_cooldown[alert_key] = current_time
            return True

        return False
        """Create raw socket for packet capture"""
        try:
            # Create raw socket (requires root/admin privileges)
            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            return s
        except PermissionError:
            self.logger.error("Raw socket requires root/administrator privileges")
            return None
        except Exception as e:
            self.logger.error(f"Error creating raw socket: {e}")
            return None

    def parse_ip_header(self, data):
        """Parse IP header from raw packet data"""
        try:
            # Unpack the first 20 bytes (IP header)
            ip_header = struct.unpack('!BBHHHBBH4s4s', data[:20])

            version_ihl = ip_header[0]
            version = version_ihl >> 4
            ihl = (version_ihl & 0xF) * 4

            protocol = ip_header[6]
            src_ip = socket.inet_ntoa(ip_header[8])
            dst_ip = socket.inet_ntoa(ip_header[9])

            return {
                'version': version,
                'ihl': ihl,
                'protocol': protocol,
                'src_ip': src_ip,
                'dst_ip': dst_ip,
                'header_length': ihl
            }
        except Exception as e:
            self.logger.debug(f"Error parsing IP header: {e}")
            return None

    def parse_tcp_header(self, data, ip_header_length):
        """Parse TCP header from packet data"""
        try:
            tcp_header_start = ip_header_length
            tcp_header = struct.unpack('!HHLLBBHHH', data[tcp_header_start:tcp_header_start+20])

            src_port = tcp_header[0]
            dst_port = tcp_header[1]
            flags = tcp_header[5]

            return {
                'src_port': src_port,
                'dst_port': dst_port,
                'flags': flags,
                'syn': bool(flags & 0x02),
                'ack': bool(flags & 0x10),
                'fin': bool(flags & 0x01),
                'rst': bool(flags & 0x04)
            }
        except Exception as e:
            self.logger.debug(f"Error parsing TCP header: {e}")
            return None

    def detect_port_scan(self, src_ip, dst_port):
        """Detect potential port scanning activity"""
        current_time = time.time()

        # Add current port to the tracking deque
        self.port_scan_detector[src_ip].append((dst_port, current_time))

        # Count unique ports accessed in the last minute
        recent_ports = set()
        for port, timestamp in self.port_scan_detector[src_ip]:
            if current_time - timestamp <= 60:  # Last minute
                recent_ports.add(port)

        if len(recent_ports) >= self.port_scan_threshold:
            return True
        return False

    def detect_suspicious_activity(self, packet_info):
        """Analyze packet for suspicious patterns"""
        alerts = []
        src_ip = packet_info['ip']['src_ip']
        dst_port = packet_info.get('tcp', {}).get('dst_port', 0)
        current_time = time.time()

        # Check for port scanning
        if self.detect_port_scan(src_ip, dst_port):
            alert_key = f"PORT_SCAN_{src_ip}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'PORT_SCAN',
                    'severity': 'HIGH',
                    'src_ip': src_ip,
                    'description': f'Potential port scan detected from {src_ip}',
                    'timestamp': datetime.now().isoformat()
                })
                self.suspicious_ips.add(src_ip)

        # Check for connections to suspicious ports
        if dst_port in self.suspicious_ports:
            alert_key = f"SUSPICIOUS_PORT_{src_ip}_{dst_port}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'SUSPICIOUS_PORT',
                    'severity': 'MEDIUM',
                    'src_ip': src_ip,
                    'dst_port': dst_port,
                    'description': f'Connection to commonly targeted port {dst_port} from {src_ip}',
                    'timestamp': datetime.now().isoformat()
                })

        # Check for high connection rate
        self.connection_tracker[src_ip].append(current_time)

        # Clean old connections (older than 1 minute)
        self.connection_tracker[src_ip] = [
            t for t in self.connection_tracker[src_ip]
            if current_time - t <= 60
        ]

        connection_count = len(self.connection_tracker[src_ip])
        if connection_count > self.connection_threshold:
            alert_key = f"HIGH_CONNECTION_RATE_{src_ip}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'HIGH_CONNECTION_RATE',
                    'severity': 'HIGH',
                    'src_ip': src_ip,
                    'connection_count': connection_count,
                    'description': f'High connection rate from {src_ip}: {connection_count} connections/minute',
                    'timestamp': datetime.now().isoformat()
                })
                self.suspicious_ips.add(src_ip)

        return alerts

    def process_packet(self, data):
        """Process individual network packet"""
        ip_info = self.parse_ip_header(data)
        if not ip_info or ip_info['protocol'] != 6:  # Only process TCP packets
            return

        tcp_info = self.parse_tcp_header(data, ip_info['header_length'])
        if not tcp_info:
            return

        packet_info = {
            'ip': ip_info,
            'tcp': tcp_info,
            'timestamp': datetime.now().isoformat()
        }

        # Update traffic statistics
        self.traffic_stats[ip_info['src_ip']] += 1
        self.traffic_stats['total_packets'] += 1

        # Detect suspicious activity
        alerts = self.detect_suspicious_activity(packet_info)

        # Log alerts
        for alert in alerts:
            self.alerts.append(alert)
            self.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

    def start_monitoring(self, duration=60):
        """Start network monitoring for specified duration"""
        sock = self.create_raw_socket()
        if not sock:
            self.logger.error("Cannot start monitoring without raw socket")
            return

        self.running = True
        self.logger.info("Starting network intrusion detection...")

        start_time = time.time()
        try:
            while self.running and (time.time() - start_time < duration):
                try:
                    data, addr = sock.recvfrom(65535)
                    self.process_packet(data)
                except socket.timeout:
                    continue
                except Exception as e:
                    self.logger.debug(f"Packet processing error: {e}")

        except KeyboardInterrupt:
            self.logger.info("Monitoring stopped by user")
        finally:
            sock.close()
            self.running = False

    def generate_report(self):
        """Generate security report"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'monitoring_duration': '60 seconds',
            'total_packets': self.traffic_stats['total_packets'],
            'total_alerts': len(self.alerts),
            'suspicious_ips': list(self.suspicious_ips),
            'top_talkers': dict(sorted(
                {k: v for k, v in self.traffic_stats.items() if k != 'total_packets'}.items(),
                key=lambda x: x[1], reverse=True
            )[:10]),
            'alerts_by_type': {},
            'recent_alerts': self.alerts[-10:]  # Last 10 alerts
        }

        # Count alerts by type
        for alert in self.alerts:
            alert_type = alert['type']
            if alert_type not in report['alerts_by_type']:
                report['alerts_by_type'][alert_type] = 0
            report['alerts_by_type'][alert_type] += 1

        return report

    def save_report(self, filename='nids_report.json'):
        """Save report to JSON file"""
        report = self.generate_report()
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        self.logger.info(f"Report saved to {filename}")
        return report

# Simulated packet generator for testing (when raw sockets aren't available)
class PacketSimulator:
    def __init__(self, ids_system):
        self.ids = ids_system

    def simulate_normal_traffic(self):
        """Simulate normal network traffic"""
        import random

        normal_ips = ['192.168.1.10', '192.168.1.11', '192.168.1.12']
        normal_ports = [80, 443, 8080]

        for _ in range(50):
            src_ip = random.choice(normal_ips)
            dst_port = random.choice(normal_ports)

            # Simulate packet info
            packet_info = {
                'ip': {'src_ip': src_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': dst_port, 'src_port': random.randint(1024, 65535)}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.1)

    def simulate_port_scan(self):
        """Simulate port scanning attack"""
        attacker_ip = '10.0.0.100'

        self.ids.logger.info("Simulating port scan attack...")
        for port in range(20, 35):  # Scan ports 20-34
            packet_info = {
                'ip': {'src_ip': attacker_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': port, 'src_port': 12345}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.2)

# Main execution
if __name__ == "__main__":
    # Create IDS instance
    nids = NetworkIDS()

    print("Network Intrusion Detection System")
    print("=" * 40)

    # Check if we can use raw sockets
    test_socket = nids.create_raw_socket()
    if test_socket:
        test_socket.close()
        print("Raw socket available - starting real network monitoring...")
        nids.start_monitoring(duration=30)  # Monitor for 30 seconds
    else:
        print("Raw socket not available - running simulation mode...")
        simulator = PacketSimulator(nids)

        # Run simulations in separate threads
        import threading

        normal_thread = threading.Thread(target=simulator.simulate_normal_traffic)
        scan_thread = threading.Thread(target=simulator.simulate_port_scan)

        normal_thread.start()
        time.sleep(2)
        scan_thread.start()

        normal_thread.join()
        scan_thread.join()

    # Generate and display report
    print("\nGenerating security report...")
    report = nids.save_report()

    print(f"\nSecurity Report Summary:")
    print(f"Total Packets: {report['total_packets']}")
    print(f"Total Alerts: {report['total_alerts']}")
    print(f"Suspicious IPs: {len(report['suspicious_ips'])}")

    if report['alerts_by_type']:
        print("\nAlerts by Type:")
        for alert_type, count in report['alerts_by_type'].items():
            print(f"  {alert_type}: {count}")

    if report['recent_alerts']:
        print("\nRecent Alerts:")
        for alert in report['recent_alerts'][-3:]:  # Show last 3
            print(f"  {alert['type']}: {alert['description']}")

#!/usr/bin/env python3
"""
Network Intrusion Detection System (NIDS)
Educational implementation for legitimate security monitoring
"""

import socket
import struct
import threading
import time
import json
import logging
from datetime import datetime
from collections import defaultdict, deque
import ipaddress

class NetworkIDS:
    def __init__(self):
        self.alerts = []
        self.traffic_stats = defaultdict(int)
        self.connection_tracker = defaultdict(list)
        self.suspicious_ips = set()
        self.port_scan_detector = defaultdict(lambda: deque(maxlen=50))
        self.alert_cooldown = defaultdict(float)  # Track last alert time per IP
        self.running = False

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('nids.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)

        # Define suspicious ports (commonly targeted)
        self.suspicious_ports = {
            21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443,
            993, 995, 1433, 1521, 3306, 3389, 5432, 5900
        }

        # Rate limiting thresholds
        self.connection_threshold = 50  # connections per IP per minute
        self.port_scan_threshold = 10   # different ports per IP per minute
        self.alert_cooldown_period = 60  # seconds between duplicate alerts

    def should_alert(self, alert_key, current_time):
        """Check if enough time has passed since last alert of this type for this IP"""
        if alert_key not in self.alert_cooldown:
            self.alert_cooldown[alert_key] = current_time
            return True

        if current_time - self.alert_cooldown[alert_key] >= self.alert_cooldown_period:
            self.alert_cooldown[alert_key] = current_time
            return True

        return False
        """Create raw socket for packet capture"""
        try:
            # Create raw socket (requires root/admin privileges)
            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            return s
        except PermissionError:
            self.logger.error("Raw socket requires root/administrator privileges")
            return None
        except Exception as e:
            self.logger.error(f"Error creating raw socket: {e}")
            return None

    def parse_ip_header(self, data):
        """Parse IP header from raw packet data"""
        try:
            # Unpack the first 20 bytes (IP header)
            ip_header = struct.unpack('!BBHHHBBH4s4s', data[:20])

            version_ihl = ip_header[0]
            version = version_ihl >> 4
            ihl = (version_ihl & 0xF) * 4

            protocol = ip_header[6]
            src_ip = socket.inet_ntoa(ip_header[8])
            dst_ip = socket.inet_ntoa(ip_header[9])

            return {
                'version': version,
                'ihl': ihl,
                'protocol': protocol,
                'src_ip': src_ip,
                'dst_ip': dst_ip,
                'header_length': ihl
            }
        except Exception as e:
            self.logger.debug(f"Error parsing IP header: {e}")
            return None

    def parse_tcp_header(self, data, ip_header_length):
        """Parse TCP header from packet data"""
        try:
            tcp_header_start = ip_header_length
            tcp_header = struct.unpack('!HHLLBBHHH', data[tcp_header_start:tcp_header_start+20])

            src_port = tcp_header[0]
            dst_port = tcp_header[1]
            flags = tcp_header[5]

            return {
                'src_port': src_port,
                'dst_port': dst_port,
                'flags': flags,
                'syn': bool(flags & 0x02),
                'ack': bool(flags & 0x10),
                'fin': bool(flags & 0x01),
                'rst': bool(flags & 0x04)
            }
        except Exception as e:
            self.logger.debug(f"Error parsing TCP header: {e}")
            return None

    def detect_port_scan(self, src_ip, dst_port):
        """Detect potential port scanning activity"""
        current_time = time.time()

        # Add current port to the tracking deque
        self.port_scan_detector[src_ip].append((dst_port, current_time))

        # Count unique ports accessed in the last minute
        recent_ports = set()
        for port, timestamp in self.port_scan_detector[src_ip]:
            if current_time - timestamp <= 60:  # Last minute
                recent_ports.add(port)

        if len(recent_ports) >= self.port_scan_threshold:
            return True
        return False

    def detect_suspicious_activity(self, packet_info):
        """Analyze packet for suspicious patterns"""
        alerts = []
        src_ip = packet_info['ip']['src_ip']
        dst_port = packet_info.get('tcp', {}).get('dst_port', 0)
        current_time = time.time()

        # Check for port scanning
        if self.detect_port_scan(src_ip, dst_port):
            alert_key = f"PORT_SCAN_{src_ip}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'PORT_SCAN',
                    'severity': 'HIGH',
                    'src_ip': src_ip,
                    'description': f'Potential port scan detected from {src_ip}',
                    'timestamp': datetime.now().isoformat()
                })
                self.suspicious_ips.add(src_ip)

        # Check for connections to suspicious ports
        if dst_port in self.suspicious_ports:
            alert_key = f"SUSPICIOUS_PORT_{src_ip}_{dst_port}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'SUSPICIOUS_PORT',
                    'severity': 'MEDIUM',
                    'src_ip': src_ip,
                    'dst_port': dst_port,
                    'description': f'Connection to commonly targeted port {dst_port} from {src_ip}',
                    'timestamp': datetime.now().isoformat()
                })

        # Check for high connection rate
        self.connection_tracker[src_ip].append(current_time)

        # Clean old connections (older than 1 minute)
        self.connection_tracker[src_ip] = [
            t for t in self.connection_tracker[src_ip]
            if current_time - t <= 60
        ]

        connection_count = len(self.connection_tracker[src_ip])
        if connection_count > self.connection_threshold:
            alert_key = f"HIGH_CONNECTION_RATE_{src_ip}"
            if self.should_alert(alert_key, current_time):
                alerts.append({
                    'type': 'HIGH_CONNECTION_RATE',
                    'severity': 'HIGH',
                    'src_ip': src_ip,
                    'connection_count': connection_count,
                    'description': f'High connection rate from {src_ip}: {connection_count} connections/minute',
                    'timestamp': datetime.now().isoformat()
                })
                self.suspicious_ips.add(src_ip)

        return alerts

    def process_packet(self, data):
        """Process individual network packet"""
        ip_info = self.parse_ip_header(data)
        if not ip_info or ip_info['protocol'] != 6:  # Only process TCP packets
            return

        tcp_info = self.parse_tcp_header(data, ip_info['header_length'])
        if not tcp_info:
            return

        packet_info = {
            'ip': ip_info,
            'tcp': tcp_info,
            'timestamp': datetime.now().isoformat()
        }

        # Update traffic statistics
        self.traffic_stats[ip_info['src_ip']] += 1
        self.traffic_stats['total_packets'] += 1

        # Detect suspicious activity
        alerts = self.detect_suspicious_activity(packet_info)

        # Log alerts
        for alert in alerts:
            self.alerts.append(alert)
            self.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

    def start_monitoring(self, duration=60):
        """Start network monitoring for specified duration"""
        sock = self.create_raw_socket()
        if not sock:
            self.logger.error("Cannot start monitoring without raw socket")
            return

        self.running = True
        self.logger.info("Starting network intrusion detection...")

        start_time = time.time()
        try:
            while self.running and (time.time() - start_time < duration):
                try:
                    data, addr = sock.recvfrom(65535)
                    self.process_packet(data)
                except socket.timeout:
                    continue
                except Exception as e:
                    self.logger.debug(f"Packet processing error: {e}")

        except KeyboardInterrupt:
            self.logger.info("Monitoring stopped by user")
        finally:
            sock.close()
            self.running = False

    def generate_report(self):
        """Generate security report"""
        report = {
            'timestamp': datetime.now().isoformat(),
            'monitoring_duration': '60 seconds',
            'total_packets': self.traffic_stats['total_packets'],
            'total_alerts': len(self.alerts),
            'suspicious_ips': list(self.suspicious_ips),
            'top_talkers': dict(sorted(
                {k: v for k, v in self.traffic_stats.items() if k != 'total_packets'}.items(),
                key=lambda x: x[1], reverse=True
            )[:10]),
            'alerts_by_type': {},
            'recent_alerts': self.alerts[-10:]  # Last 10 alerts
        }

        # Count alerts by type
        for alert in self.alerts:
            alert_type = alert['type']
            if alert_type not in report['alerts_by_type']:
                report['alerts_by_type'][alert_type] = 0
            report['alerts_by_type'][alert_type] += 1

        return report

    def save_report(self, filename='nids_report.json'):
        """Save report to JSON file"""
        report = self.generate_report()
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        self.logger.info(f"Report saved to {filename}")
        return report

# Simulated packet generator for testing (when raw sockets aren't available)
class PacketSimulator:
    def __init__(self, ids_system):
        self.ids = ids_system

    def simulate_normal_traffic(self):
        """Simulate normal network traffic"""
        import random

        normal_ips = ['192.168.1.10', '192.168.1.11', '192.168.1.12']
        normal_ports = [80, 443, 8080]

        for _ in range(50):
            src_ip = random.choice(normal_ips)
            dst_port = random.choice(normal_ports)

            # Simulate packet info
            packet_info = {
                'ip': {'src_ip': src_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': dst_port, 'src_port': random.randint(1024, 65535)}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.1)

    def simulate_port_scan(self):
        """Simulate port scanning attack"""
        attacker_ip = '10.0.0.100'

        self.ids.logger.info("Simulating port scan attack...")
        for port in range(20, 35):  # Scan ports 20-34
            packet_info = {
                'ip': {'src_ip': attacker_ip, 'dst_ip': '192.168.1.1'},
                'tcp': {'dst_port': port, 'src_port': 12345}
            }

            alerts = self.ids.detect_suspicious_activity(packet_info)
            for alert in alerts:
                self.ids.alerts.append(alert)
                self.ids.logger.warning(f"ALERT: {alert['type']} - {alert['description']}")

            time.sleep(0.2)

# Main execution
if __name__ == "__main__":
    # Create IDS instance
    nids = NetworkIDS()

    print("Network Intrusion Detection System")
    print("=" * 40)

    # Check if we can use raw sockets
    try:
        test_socket = nids.create_raw_socket()
        if test_socket:
            test_socket.close()
            print("Raw socket available - starting real network monitoring...")
            nids.start_monitoring(duration=30)  # Monitor for 30 seconds
        else:
            print("Raw socket not available - running simulation mode...")
            simulator = PacketSimulator(nids)
    except AttributeError as e:
        print(f"Error accessing raw socket method: {e}")
        print("Running in simulation mode...")
        simulator = PacketSimulator(nids)

        # Run simulations in separate threads
        import threading

        normal_thread = threading.Thread(target=simulator.simulate_normal_traffic)
        scan_thread = threading.Thread(target=simulator.simulate_port_scan)

        normal_thread.start()
        time.sleep(2)
        scan_thread.start()

        normal_thread.join()
        scan_thread.join()

    # Generate and display report
    print("\nGenerating security report...")
    report = nids.save_report()

    print(f"\nSecurity Report Summary:")
    print(f"Total Packets: {report['total_packets']}")
    print(f"Total Alerts: {report['total_alerts']}")
    print(f"Suspicious IPs: {len(report['suspicious_ips'])}")

    if report['alerts_by_type']:
        print("\nAlerts by Type:")
        for alert_type, count in report['alerts_by_type'].items():
            print(f"  {alert_type}: {count}")

    if report['recent_alerts']:
        print("\nRecent Alerts:")
        for alert in report['recent_alerts'][-3:]:  # Show last 3
            print(f"  {alert['type']}: {alert['description']}")